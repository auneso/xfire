/* safe memory allocation */
/* 2008/10/01 - HDS */

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "xstring.h"
#include "xalloc.h"

#define MEM_BLOCK_LIMIT     (60*1024*1024) /* 60Mb */
//#define XALLOC_DEBUG


static void xmem_abort (char *msg, size_t size)
{ 
  printf("$$$$ ERROR %s size = %ld $$$$\n", msg, size);
  abort();
} 

#ifdef XALLOC_DEBUG /* { */
#error XALLOC_DEBUG
static long xmem_limit = -1;
static int malloc_called = 0;
static int calloc_called = 0;
static int realloc_called = 0;

static int free_called = 0;
static size_t xmem_cur_size = 0;
static size_t xmem_max_size = 0;

#define XMEM_HEADER ((0x2B2B56 << 16) + 0x1F6781)
#define XMEM_FOOTER 0xdeadbeef

struct xmemheader {
  size_t size;
  unsigned int redzone;
};

struct xmemfooter {
  unsigned int redzone[2];
};

static __inline__ size_t
ptr_size (size_t size)
{
#ifdef XMEM_STAT
  size += sizeof(struct xmemheader);
#endif


#ifdef XMEM_REDZONE
  size += sizeof(struct xmemfooter);
#endif

  return size;
}


static __inline__ void *
set_ptr (void *ptr, size_t size)
{
#ifdef XMEM_STAT
  struct xmemheader head;
  head.redzone = XMEM_HEADER;
  head.size = size;
  memcpy(ptr, &head, sizeof(head));
#endif

#ifdef XMEM_REDZONE
  {
    static struct xmemfooter foot = { { XMEM_FOOTER, XMEM_FOOTER } };
    memcpy((char *)ptr + sizeof(head) + size, &foot, sizeof(foot));
  }
#endif

#ifdef XMEM_STAT
  return (char *)ptr + sizeof(head);
#else
  return ptr;


#endif /* XMEM_STAT */
}


static __inline__ void *
get_ptr (void *ptr)
{
#ifdef XMEM_STAT
  return (char *)ptr - sizeof(struct xmemheader);
#else
  return (char *)ptr;
#endif
}


static __inline__ int add_stat (size_t size)
{
  if (xmem_limit > 0 && xmem_cur_size + size > xmem_limit)
    return -1;
  xmem_cur_size += size;
  if (xmem_max_size < xmem_cur_size)
    xmem_max_size = xmem_cur_size;
  return 0;
}


void *xmalloc (size_t size)
{
  void *ptr;

  if (size < 1) size = 1;

  ptr = malloc(ptr_size(size));
  if (!ptr || add_stat(size) < 0)
    xmem_abort("xmalloc", size);
  malloc_called++;
  return set_ptr(ptr, size);
}

void *xcalloc (size_t nmemb, size_t size)
{
  void *ptr;

  size = size * nmemb;
  if (size < 1) size = 1;

  ptr = malloc(ptr_size(size));
  if (!ptr || add_stat(size) < 0)
    xmem_abort("xcalloc", size);
  calloc_called++;
  ptr = set_ptr(ptr, size);
  memset(ptr, 0, size);
  return ptr;
}

void *xzalloc (size_t size)
{
  return xcalloc (1, size);
}

void * xrealloc (void *ptr, size_t size)
{
  if (ptr == NULL) 
    return  xmalloc(size);

  if (size  < 1) size = 1;

  ptr = get_ptr(ptr);
  ptr = realloc(ptr, ptr_size(size));
  if (!ptr || add_stat(size) < 0)
    xmem_abort("xrealloc", size);
  realloc_called++;
  return set_ptr(ptr, size);
}


static __inline__ int
redzone_check (void *ptr, size_t size)
{
#ifdef XMEM_REDZONE
  int i = 0;
  struct xmemfooter *p
   = (struct xmemfooter *)((char *)ptr + sizeof(struct xmemheader) + size);

  while (i < sizeof(p->redzone) / sizeof(int)) {
    if (p->redzone[i] != XMEM_FOOTER)
      return -1;
    i++;
  }
#endif /* XMEM_REDZONE */
  return 0;
}


void xfree (void *ptr)
{
  if (!ptr) xmem_abort("xfree_1", 0);

#ifdef XMEM_STAT
  {
    struct xmemheader *p;
    p = (struct xmemheader *)get_ptr(ptr);
    if (p->redzone != XMEM_HEADER) {
      /* Invalid usage of xfree(), PTR wasn't generated by xmalloc() */
      fprintf(stderr, "error: xfree() failed: redzone is not valid\n");
      xmem_abort("xfree_2". 0);
    }

    xmem_cur_size -= p->size;
    if (redzone_check(p, p->size) < 0)
      xmem_abort("xfree_3". 0);
  }
#endif

  free_called++;
  free(get_ptr(ptr));
}


void
xmemstat (memstat_t *ms)
{
  ms->malloc_called  = malloc_called;
  ms->calloc_called  = calloc_called;
  ms->realloc_called = realloc_called;
  ms->free_called    = free_called;

  ms->cur_size = xmem_cur_size;
  ms->max_size = xmem_max_size;
  ms->limit    = xmem_limit;
}

void xmemdump (void)
{ 
  printf("malloc = %d, calloc = %d, realloc = %d, free = %d, alloc = %d\n", 
         malloc_called, calloc_called, realloc_called, free_called,
         malloc_called+ calloc_called+ realloc_called- free_called);

  printf("mem_cursize = %ld, xmem_max_size = %ld, xmem_limit = %ld\n\n", 
         xmem_cur_size, xmem_max_size, xmem_limit);
}

void xmemreset (void)
{
  malloc_called = 0;
  calloc_called = 0;
  realloc_called = 0;
  free_called = 0;

  xmem_cur_size = 0;
  xmem_max_size = 0;
  xmem_limit = -1;
}

#else /* } */

void *xmalloc (size_t size)
{
  void *x;

  if (size < 1) size = 1;

  x = malloc(size);
  if (x == NULL) {
    xmem_abort("xmalloc", size); 
  }
  return x;
}

void xfree (void *ptr)
{
  if (ptr) free(ptr);
}

void *xzalloc (size_t size)
{
  void *x;
  
  if (size < 1) size = 1;

  x = malloc(size);
  if (x == NULL) {
    xmem_abort("xzalloc", size);
  }
  memset((char *)x, 0, size); 
  return x;
}

void *xcalloc (size_t nmemb, size_t size)
{
  void *x;
  
  if (size < 1) size = 1;

  x = malloc(nmemb * size);
  if (x == NULL) {
    xmem_abort("xcalloc", size);
  }
  memset((char *)x, 0, nmemb * size); 
  return x;
}

void *xrealloc (void *ptr, size_t size)
{
  void *x;

  if (size < 1) size = 1;
  
  if (ptr == NULL) 
    return  xmalloc(size);
  x = realloc(ptr, size);
  if (x == NULL) xmem_abort("xealloc", size);
  return x;
}


void xmemstat (memstat_t *ms) { ms = ms; }

void xmemdump (void) { }

void xmemreset (void) { }
#endif

char *xstrdup (char *str)
{
  char *ptr;

  if (!str) return NULL;
  ptr = xmalloc(strlen(str) + 1);
  strcpy(ptr, str);
  return ptr; 
}

char *xstrndup (char *str, int len)
{
  char *ptr;

  if (!str) return NULL;
  ptr = xmalloc(len + 1);
  memcpy(ptr, str, len);
  ptr[len] = 0;
  return ptr; 
}

char *xstrndup_lowcase (char *str, int len)
{
  char *ptr;
  int i;

  if (!str) return NULL;
  ptr = xmalloc(len + 1);
  for (i = 0; i < len; i++)
    ptr[i] = ToLower(str[i]);
  ptr[i] = 0;
  return ptr;
}

void *xmemdup (void *str, int len)
{
  char *ptr = xmalloc(len);
  memcpy(ptr, str, len);
  return ptr; 
}

void *xresize (void *p, int nbytes)
{
  if (p == 0) return xmalloc(nbytes);
  return p = xrealloc(p, nbytes);
}

